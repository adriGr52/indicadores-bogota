from fastapi import FastAPI, HTTPException, UploadFile, File, Query, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Index, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import pandas as pd
import numpy as np
import json
import io
import os
from datetime import datetime
import logging
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# Configuración
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///fecundidad_temprana.db")
if DATABASE_URL.startswith("postgres://"):
    DATABASE_URL = DATABASE_URL.replace("postgres://", "postgresql://", 1)

engine = create_engine(DATABASE_URL, echo=False)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Modelo de datos optimizado para tu estructura Excel
class IndicadorFecundidad(Base):
    __tablename__ = "indicadores_fecundidad"
    
    id = Column(Integer, primary_key=True, index=True)
    archivo_hash = Column(String, index=True)
    indicador_nombre = Column(String, index=True, nullable=False)
    dimension = Column(String)
    unidad_medida = Column(String, nullable=False)
    tipo_medida = Column(String)
    valor = Column(Float, nullable=False)
    nivel_territorial = Column(String, index=True, nullable=False)
    id_localidad = Column(Integer, index=True)
    nombre_localidad = Column(String, index=True, nullable=False)
    id_upz = Column(Integer, index=True)
    nombre_upz = Column(String, index=True)
    area_geografica = Column(String)
    año_inicio = Column(Integer)
    periodicidad = Column(String)
    poblacion_base = Column(String)
    semaforo = Column(String)
    grupo_etario_asociado = Column(String, index=True)
    sexo = Column(String)
    tipo_unidad = Column(String)
    observacion = Column(String)
    fuente = Column(String)
    url_fuente = Column(String)
    fecha_carga = Column(DateTime, default=datetime.now)
    
    __table_args__ = (
        Index('idx_localidad_indicador', 'nombre_localidad', 'indicador_nombre'),
        Index('idx_upz_grupo', 'nombre_upz', 'grupo_etario_asociado'),
        Index('idx_nivel_año', 'nivel_territorial', 'año_inicio'),
    )

# Modelos Pydantic
class IndicadorResponse(BaseModel):
    id: int
    indicador_nombre: str
    nombre_localidad: str
    nombre_upz: Optional[str]
    nivel_territorial: str
    valor: float
    unidad_medida: str
    grupo_etario_asociado: Optional[str]
    semaforo: Optional[str]

class EstadisticasResponse(BaseModel):
    total_registros: int
    localidades_unicas: int
    upzs_unicas: int
    indicadores_unicos: int
    promedio_10_14: float
    promedio_15_19: float
    localidad_mayor_riesgo: str
    localidad_menor_riesgo: str
    años_disponibles: List[int]

Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

app = FastAPI(
    title="API Determinantes de Fecundidad Temprana - Bogotá D.C.",
    description="API especializada para análisis de fecundidad temprana con datos oficiales",
    version="2.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Funciones auxiliares
def extraer_grupo_edad(indicador_nombre: str, grupo_etario: str) -> str:
    """Extrae grupo de edad del indicador"""
    indicador_lower = indicador_nombre.lower() if indicador_nombre else ""
    grupo_lower = grupo_etario.lower() if grupo_etario else ""
    
    if any(x in indicador_lower for x in ["10", "14"]) or any(x in grupo_lower for x in ["10", "14"]):
        return "10-14"
    elif any(x in indicador_lower for x in ["15", "19"]) or any(x in grupo_lower for x in ["15", "19"]):
        return "15-19"
    return "15-19"  # Por defecto

def calcular_nivel_riesgo(valor: float, grupo_edad: str) -> str:
    """Calcula nivel de riesgo según estándares epidemiológicos"""
    if grupo_edad == "10-14":
        if valor >= 5.0: return "CRÍTICO"
        elif valor >= 2.0: return "ALTO"
        elif valor >= 0.5: return "MODERADO"
        else: return "BAJO"
    else:  # 15-19
        if valor >= 80.0: return "CRÍTICO"
        elif valor >= 60.0: return "ALTO"
        elif valor >= 40.0: return "MODERADO"
        else: return "BAJO"

@app.get("/", response_class=HTMLResponse)
async def dashboard():
    """Servir dashboard principal"""
    try:
        with open("dashboard_compatible.html", "r", encoding="utf-8") as f:
            return HTMLResponse(content=f.read())
    except FileNotFoundError:
        return HTMLResponse(content="""
        <h1>🚀 API Fecundidad Temprana</h1>
        <p>Dashboard en desarrollo. Endpoints disponibles:</p>
        <ul>
            <li><a href="/docs">/docs - Documentación interactiva</a></li>
            <li><a href="/estadisticas/generales">/estadisticas/generales</a></li>
            <li><a href="/datos/localidades">/datos/localidades</a></li>
        </ul>
        """)

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "API Fecundidad Temprana"}

@app.post("/upload/excel")
async def upload_excel(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Cargar datos desde archivo Excel con estructura específica"""
    if not file.filename.endswith(('.xlsx', '.xls')):
        raise HTTPException(status_code=400, detail="Formato no válido. Use archivos Excel (.xlsx, .xls)")
    
    try:
        contents = await file.read()
        df = pd.read_excel(io.BytesIO(contents), sheet_name=0)  # Solo primera hoja
        
        logger.info(f"Archivo cargado: {len(df)} filas, {len(df.columns)} columnas")
        
        # Limpiar datos existentes
        db.query(IndicadorFecundidad).delete()
        
        registros_cargados = 0
        errores = 0
        
        for _, row in df.iterrows():
            try:
                # Filtrar solo indicadores de fecundidad temprana
                indicador = str(row.get('Indicador_Nombre', '')).lower()
                if 'fecundidad' not in indicador:
                    continue
                
                registro = IndicadorFecundidad(
                    archivo_hash=str(row.get('archivo_hash', '')),
                    indicador_nombre=str(row.get('Indicador_Nombre', '')).strip(),
                    dimension=str(row.get('Dimensión', '')),
                    unidad_medida=str(row.get('Unidad_Medida', '')),
                    tipo_medida=str(row.get('Tipo_Medida', '')),
                    valor=float(row.get('Valor', 0)) if pd.notna(row.get('Valor')) else 0.0,
                    nivel_territorial=str(row.get('Nivel_Territorial', '')).upper(),
                    id_localidad=int(row.get('ID Localidad', 0)) if pd.notna(row.get('ID Localidad')) else None,
                    nombre_localidad=str(row.get('Nombre Localidad', '')).strip(),
                    id_upz=int(row.get('ID_UPZ', 0)) if pd.notna(row.get('ID_UPZ')) else None,
                    nombre_upz=str(row.get('Nombre_UPZ', '')).strip() if pd.notna(row.get('Nombre_UPZ')) else None,
                    area_geografica=str(row.get('Área Geográfica', '')),
                    año_inicio=int(row.get('Año_Inicio', 0)) if pd.notna(row.get('Año_Inicio')) else None,
                    periodicidad=str(row.get('Periodicidad', '')),
                    poblacion_base=str(row.get('Poblacion Base', '')),
                    semaforo=str(row.get('Semaforo', '')),
                    grupo_etario_asociado=str(row.get('Grupo Etario Asociado', '')),
                    sexo=str(row.get('Sexo', '')),
                    tipo_unidad=str(row.get('Tipo de Unidad', '')),
                    observacion=str(row.get('Observación', '')),
                    fuente=str(row.get('Fuente', '')),
                    url_fuente=str(row.get('URL_Fuente (Opcional)', ''))
                )
                
                db.add(registro)
                registros_cargados += 1
                
            except Exception as e:
                errores += 1
                logger.warning(f"Error en fila: {e}")
                continue
        
        db.commit()
        
        return {
            "status": "success",
            "mensaje": "Datos de fecundidad temprana cargados exitosamente",
            "registros_cargados": registros_cargados,
            "total_filas_procesadas": len(df),
            "errores": errores
        }
        
    except Exception as e:
        logger.error(f"Error cargando archivo: {e}")
        raise HTTPException(status_code=500, detail=f"Error procesando archivo: {str(e)}")

@app.get("/estadisticas/generales")
async def estadisticas_generales(db: Session = Depends(get_db)):
    """Estadísticas generales del sistema"""
    try:
        total_registros = db.query(IndicadorFecundidad).count()
        
        if total_registros == 0:
            return {
                "total_registros": 0,
                "localidades_unicas": 0,
                "upzs_unicas": 0,
                "indicadores_unicos": 0,
                "promedio_10_14": 0.0,
                "promedio_15_19": 0.0,
                "localidad_mayor_riesgo": "Sin datos",
                "localidad_menor_riesgo": "Sin datos",
                "años_disponibles": [],
                "mensaje": "No hay datos cargados. Por favor, carga un archivo Excel."
            }
        
        localidades = db.query(IndicadorFecundidad.nombre_localidad).distinct().count()
        upzs = db.query(IndicadorFecundidad.nombre_upz).filter(IndicadorFecundidad.nombre_upz.isnot(None)).distinct().count()
        indicadores = db.query(IndicadorFecundidad.indicador_nombre).distinct().count()
        
        # Promedios por grupo de edad (usando el indicador)
        registros_10_14 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%14%")
        ).all()
        
        registros_15_19 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%19%")
        ).all()
        
        prom_10_14 = np.mean([r.valor for r in registros_10_14]) if registros_10_14 else 0.0
        prom_15_19 = np.mean([r.valor for r in registros_15_19]) if registros_15_19 else 0.0
        
        # Localidades con mayor y menor riesgo
        localidades_riesgo = db.query(
            IndicadorFecundidad.nombre_localidad,
            func.avg(IndicadorFecundidad.valor).label('promedio')
        ).group_by(IndicadorFecundidad.nombre_localidad).all()
        
        if localidades_riesgo:
            mayor_riesgo = max(localidades_riesgo, key=lambda x: x.promedio).nombre_localidad
            menor_riesgo = min(localidades_riesgo, key=lambda x: x.promedio).nombre_localidad
        else:
            mayor_riesgo = menor_riesgo = "Sin datos"
        
        # Años disponibles
        años = db.query(IndicadorFecundidad.año_inicio).filter(
            IndicadorFecundidad.año_inicio.isnot(None)
        ).distinct().all()
        años_disponibles = sorted([a.año_inicio for a in años if a.año_inicio])
        
        return {
            "total_registros": total_registros,
            "localidades_unicas": localidades,
            "upzs_unicas": upzs,
            "indicadores_unicos": indicadores,
            "promedio_10_14": round(float(prom_10_14), 2),
            "promedio_15_19": round(float(prom_15_19), 2),
            "localidad_mayor_riesgo": mayor_riesgo,
            "localidad_menor_riesgo": menor_riesgo,
            "años_disponibles": años_disponibles
        }
        
    except Exception as e:
        logger.error(f"Error calculando estadísticas: {e}")
        return {
            "total_registros": 0,
            "localidades_unicas": 0,
            "upzs_unicas": 0,
            "indicadores_unicos": 0,
            "promedio_10_14": 0.0,
            "promedio_15_19": 0.0,
            "localidad_mayor_riesgo": "Error",
            "localidad_menor_riesgo": "Error",
            "años_disponibles": [],
            "error": str(e)
        }

@app.get("/datos/localidades")
async def datos_por_localidades(
    grupo_edad: Optional[str] = Query(None, description="10-14 o 15-19"),
    año: Optional[int] = Query(None, description="Filtrar por año"),
    db: Session = Depends(get_db)
):
    """Datos agregados por localidades"""
    try:
        query = db.query(IndicadorFecundidad)
        
        # Filtros
        if grupo_edad == "10-14":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%14%")
            )
        elif grupo_edad == "15-19":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%19%")
            )
        
        if año:
            query = query.filter(IndicadorFecundidad.año_inicio == año)
        
        resultados = query.all()
        
        # Agrupar por localidad
        localidades_data = {}
        for r in resultados:
            localidad = r.nombre_localidad
            if localidad not in localidades_data:
                localidades_data[localidad] = []
            localidades_data[localidad].append(r.valor)
        
        datos = []
        for localidad, valores in localidades_data.items():
            if valores:
                promedio = np.mean(valores)
                grupo_detectado = extraer_grupo_edad(
                    resultados[0].indicador_nombre if resultados else "",
                    resultados[0].grupo_etario_asociado if resultados else ""
                )
                nivel_riesgo = calcular_nivel_riesgo(promedio, grupo_detectado)
                
                datos.append({
                    "localidad": localidad,
                    "promedio": round(promedio, 2),
                    "total_registros": len(valores),
                    "maximo": round(max(valores), 2),
                    "minimo": round(min(valores), 2),
                    "nivel_riesgo": nivel_riesgo,
                    "grupo_edad": grupo_detectado
                })
        
        datos.sort(key=lambda x: x["promedio"], reverse=True)
        return {"datos": datos, "total": len(datos)}
        
    except Exception as e:
        logger.error(f"Error obteniendo datos por localidades: {e}")
        raise HTTPException(status_code=500, detail="Error obteniendo datos")

@app.get("/datos/upz")
async def datos_por_upz(
    localidad: Optional[str] = Query(None, description="Filtrar por localidad"),
    grupo_edad: Optional[str] = Query(None, description="10-14 o 15-19"),
    db: Session = Depends(get_db)
):
    """Datos agregados por UPZ"""
    try:
        query = db.query(IndicadorFecundidad).filter(IndicadorFecundidad.nombre_upz.isnot(None))
        
        if localidad:
            query = query.filter(IndicadorFecundidad.nombre_localidad == localidad)
        
        if grupo_edad == "10-14":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.contains("10") & 
                IndicadorFecundidad.indicador_nombre.contains("14")
            )
        elif grupo_edad == "15-19":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.contains("15") & 
                IndicadorFecundidad.indicador_nombre.contains("19")
            )
        
        resultados = query.all()
        
        # Agrupar por UPZ
        upz_data = {}
        for r in resultados:
            key = (r.nombre_localidad, r.nombre_upz)
            if key not in upz_data:
                upz_data[key] = []
            upz_data[key].append(r.valor)
        
        datos = []
        for (localidad, upz), valores in upz_data.items():
            if valores:
                promedio = np.mean(valores)
                grupo_detectado = extraer_grupo_edad(
                    resultados[0].indicador_nombre if resultados else "",
                    resultados[0].grupo_etario_asociado if resultados else ""
                )
                nivel_riesgo = calcular_nivel_riesgo(promedio, grupo_detectado)
                
                datos.append({
                    "localidad": localidad,
                    "upz": upz,
                    "promedio": round(promedio, 2),
                    "total_registros": len(valores),
                    "maximo": round(max(valores), 2),
                    "minimo": round(min(valores), 2),
                    "nivel_riesgo": nivel_riesgo,
                    "grupo_edad": grupo_detectado
                })
        
        datos.sort(key=lambda x: x["promedio"], reverse=True)
        return {"datos": datos, "total": len(datos)}
        
    except Exception as e:
        logger.error(f"Error obteniendo datos por UPZ: {e}")
        raise HTTPException(status_code=500, detail="Error obteniendo datos")

@app.get("/analisis/correlaciones")
async def analisis_correlaciones(
    nivel: str = Query("LOCALIDAD", description="LOCALIDAD o UPZ"),
    db: Session = Depends(get_db)
):
    """Análisis de correlaciones entre grupos de edad"""
    try:
        # Obtener datos de ambos grupos de edad
        datos_10_14 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%14%") &
            IndicadorFecundidad.nivel_territorial == nivel.upper()
        ).all()
        
        datos_15_19 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%19%") &
            IndicadorFecundidad.nivel_territorial == nivel.upper()
        ).all()
        
        if not datos_10_14 or not datos_15_19:
            return {"mensaje": "Datos insuficientes para análisis de correlación"}
        
        # Crear matrices alineadas por territorio
        territorio_map_10_14 = {}
        territorio_map_15_19 = {}
        
        for d in datos_10_14:
            key = d.nombre_localidad if nivel == "LOCALIDAD" else d.nombre_upz
            if key not in territorio_map_10_14:
                territorio_map_10_14[key] = []
            territorio_map_10_14[key].append(d.valor)
        
        for d in datos_15_19:
            key = d.nombre_localidad if nivel == "LOCALIDAD" else d.nombre_upz
            if key not in territorio_map_15_19:
                territorio_map_15_19[key] = []
            territorio_map_15_19[key].append(d.valor)
        
        # Obtener territorios comunes
        territorios_comunes = set(territorio_map_10_14.keys()) & set(territorio_map_15_19.keys())
        
        if len(territorios_comunes) < 3:
            return {"mensaje": "Datos insuficientes para correlación estadísticamente válida"}
        
        valores_10_14 = [np.mean(territorio_map_10_14[t]) for t in territorios_comunes]
        valores_15_19 = [np.mean(territorio_map_15_19[t]) for t in territorios_comunes]
        
        # Calcular correlaciones
        r_pearson, p_pearson = stats.pearsonr(valores_10_14, valores_15_19)
        r_spearman, p_spearman = stats.spearmanr(valores_10_14, valores_15_19)
        
        def interpretar_correlacion(r):
            abs_r = abs(r)
            if abs_r >= 0.8: return "Muy fuerte"
            elif abs_r >= 0.6: return "Fuerte"
            elif abs_r >= 0.4: return "Moderada"
            elif abs_r >= 0.2: return "Débil"
            else: return "Muy débil"
        
        return {
            "nivel_territorial": nivel,
            "territorios_analizados": len(territorios_comunes),
            "correlacion_pearson": round(r_pearson, 3),
            "significancia_pearson": round(p_pearson, 4),
            "correlacion_spearman": round(r_spearman, 3),
            "significancia_spearman": round(p_spearman, 4),
            "interpretacion_pearson": interpretar_correlacion(r_pearson),
            "interpretacion_spearman": interpretar_correlacion(r_spearman),
            "estadisticamente_significativo": p_pearson < 0.05,
            "datos_utilizados": {
                "promedio_10_14": round(np.mean(valores_10_14), 2),
                "promedio_15_19": round(np.mean(valores_15_19), 2),
                "territoos_comunes": list(territorios_comunes)[:10]  # Primeros 10
            }
        }
        
    except Exception as e:
        logger.error(f"Error en análisis de correlaciones: {e}")
        raise HTTPException(status_code=500, detail="Error en análisis de correlaciones")

@app.get("/analisis/ranking")
async def ranking_territorial(
    grupo_edad: str = Query("15-19", description="10-14 o 15-19"),
    nivel: str = Query("LOCALIDAD", description="LOCALIDAD o UPZ"),
    top: int = Query(10, description="Número de resultados"),
    db: Session = Depends(get_db)
):
    """Ranking de territorios por nivel de riesgo"""
    try:
        query = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.nivel_territorial == nivel.upper()
        )
        
        if grupo_edad == "10-14":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%14%")
            )
        else:
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%19%")
            )
        
        resultados = query.all()
        
        # Agrupar por territorio
        territorio_data = {}
        for r in resultados:
            territorio = r.nombre_localidad if nivel == "LOCALIDAD" else r.nombre_upz
            if territorio not in territorio_data:
                territorio_data[territorio] = []
            territorio_data[territorio].append(r.valor)
        
        # Calcular estadísticas por territorio
        ranking = []
        for territorio, valores in territorio_data.items():
            if valores:
                promedio = np.mean(valores)
                nivel_riesgo = calcular_nivel_riesgo(promedio, grupo_edad)
                
                ranking.append({
                    "territorio": territorio,
                    "promedio": round(promedio, 2),
                    "nivel_riesgo": nivel_riesgo,
                    "total_registros": len(valores),
                    "desviacion_estandar": round(np.std(valores), 2),
                    "coeficiente_variacion": round((np.std(valores) / promedio) * 100, 2) if promedio > 0 else 0
                })
        
        # Ordenar por promedio descendente
        ranking.sort(key=lambda x: x["promedio"], reverse=True)
        
        return {
            "grupo_edad": grupo_edad,
            "nivel_territorial": nivel,
            "total_territorios": len(ranking),
            "ranking_mayor_riesgo": ranking[:top],
            "ranking_menor_riesgo": ranking[-top:][::-1],
            "resumen": {
                "promedio_general": round(np.mean([r["promedio"] for r in ranking]), 2),
                "territorios_criticos": len([r for r in ranking if r["nivel_riesgo"] == "CRÍTICO"]),
                "territorios_altos": len([r for r in ranking if r["nivel_riesgo"] == "ALTO"]),
                "territorios_moderados": len([r for r in ranking if r["nivel_riesgo"] == "MODERADO"]),
                "territorios_bajos": len([r for r in ranking if r["nivel_riesgo"] == "BAJO"])
            }
        }
        
    except Exception as e:
        logger.error(f"Error en ranking territorial: {e}")
        raise HTTPException(status_code=500, detail="Error generando ranking")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT", 8000)))
