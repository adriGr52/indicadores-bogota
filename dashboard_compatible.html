from fastapi import FastAPI, HTTPException, UploadFile, File, Query, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Index, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import pandas as pd
import numpy as np
import json
import io
import os
from datetime import datetime
import logging
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# Configuraci칩n
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///fecundidad_temprana.db")
if DATABASE_URL.startswith("postgres://"):
    DATABASE_URL = DATABASE_URL.replace("postgres://", "postgresql://", 1)

engine = create_engine(DATABASE_URL, echo=False)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Modelo de datos optimizado para tu estructura Excel
class IndicadorFecundidad(Base):
    __tablename__ = "indicadores_fecundidad"
    
    id = Column(Integer, primary_key=True, index=True)
    archivo_hash = Column(String, index=True)
    indicador_nombre = Column(String, index=True, nullable=False)
    dimension = Column(String)
    unidad_medida = Column(String, nullable=False)
    tipo_medida = Column(String)
    valor = Column(Float, nullable=False)
    nivel_territorial = Column(String, index=True, nullable=False)
    id_localidad = Column(Integer, index=True)
    nombre_localidad = Column(String, index=True, nullable=False)
    id_upz = Column(Integer, index=True)
    nombre_upz = Column(String, index=True)
    area_geografica = Column(String)
    a침o_inicio = Column(Integer)
    periodicidad = Column(String)
    poblacion_base = Column(String)
    semaforo = Column(String)
    grupo_etario_asociado = Column(String, index=True)
    sexo = Column(String)
    tipo_unidad = Column(String)
    observacion = Column(String)
    fuente = Column(String)
    url_fuente = Column(String)
    fecha_carga = Column(DateTime, default=datetime.now)
    
    __table_args__ = (
        Index('idx_localidad_indicador', 'nombre_localidad', 'indicador_nombre'),
        Index('idx_upz_grupo', 'nombre_upz', 'grupo_etario_asociado'),
        Index('idx_nivel_a침o', 'nivel_territorial', 'a침o_inicio'),
    )

# Modelos Pydantic
class IndicadorResponse(BaseModel):
    id: int
    indicador_nombre: str
    nombre_localidad: str
    nombre_upz: Optional[str]
    nivel_territorial: str
    valor: float
    unidad_medida: str
    grupo_etario_asociado: Optional[str]
    semaforo: Optional[str]

class EstadisticasResponse(BaseModel):
    total_registros: int
    localidades_unicas: int
    upzs_unicas: int
    indicadores_unicos: int
    promedio_10_14: float
    promedio_15_19: float
    localidad_mayor_riesgo: str
    localidad_menor_riesgo: str
    a침os_disponibles: List[int]

Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

app = FastAPI(
    title="API Determinantes de Fecundidad Temprana - Bogot치 D.C.",
    description="API especializada para an치lisis de fecundidad temprana con datos oficiales",
    version="2.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Funciones auxiliares
def extraer_grupo_edad(indicador_nombre: str, grupo_etario: str) -> str:
    """Extrae grupo de edad del indicador"""
    indicador_lower = indicador_nombre.lower() if indicador_nombre else ""
    grupo_lower = grupo_etario.lower() if grupo_etario else ""
    
    if any(x in indicador_lower for x in ["10", "14"]) or any(x in grupo_lower for x in ["10", "14"]):
        return "10-14"
    elif any(x in indicador_lower for x in ["15", "19"]) or any(x in grupo_lower for x in ["15", "19"]):
        return "15-19"
    return "15-19"  # Por defecto

def calcular_nivel_riesgo(valor: float, grupo_edad: str) -> str:
    """Calcula nivel de riesgo seg칰n est치ndares epidemiol칩gicos"""
    if grupo_edad == "10-14":
        if valor >= 5.0: return "CR칈TICO"
        elif valor >= 2.0: return "ALTO"
        elif valor >= 0.5: return "MODERADO"
        else: return "BAJO"
    else:  # 15-19
        if valor >= 80.0: return "CR칈TICO"
        elif valor >= 60.0: return "ALTO"
        elif valor >= 40.0: return "MODERADO"
        else: return "BAJO"

@app.get("/", response_class=HTMLResponse)
async def dashboard():
    """Servir dashboard principal"""
    try:
        with open("dashboard_compatible.html", "r", encoding="utf-8") as f:
            return HTMLResponse(content=f.read())
    except FileNotFoundError:
        return HTMLResponse(content="""
        <h1>游 API Fecundidad Temprana</h1>
        <p>Dashboard en desarrollo. Endpoints disponibles:</p>
        <ul>
            <li><a href="/docs">/docs - Documentaci칩n interactiva</a></li>
            <li><a href="/estadisticas/generales">/estadisticas/generales</a></li>
            <li><a href="/datos/localidades">/datos/localidades</a></li>
        </ul>
        """)

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "API Fecundidad Temprana"}

@app.post("/upload/excel")
async def upload_excel(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Cargar datos desde archivo Excel con estructura espec칤fica"""
    if not file.filename.endswith(('.xlsx', '.xls')):
        raise HTTPException(status_code=400, detail="Formato no v치lido. Use archivos Excel (.xlsx, .xls)")
    
    try:
        contents = await file.read()
        df = pd.read_excel(io.BytesIO(contents), sheet_name=0)  # Solo primera hoja
        
        logger.info(f"Archivo cargado: {len(df)} filas, {len(df.columns)} columnas")
        
        # Limpiar datos existentes
        db.query(IndicadorFecundidad).delete()
        
        registros_cargados = 0
        errores = 0
        
        for _, row in df.iterrows():
            try:
                # Filtrar solo indicadores de fecundidad temprana
                indicador = str(row.get('Indicador_Nombre', '')).lower()
                if 'fecundidad' not in indicador:
                    continue
                
                registro = IndicadorFecundidad(
                    archivo_hash=str(row.get('archivo_hash', '')),
                    indicador_nombre=str(row.get('Indicador_Nombre', '')).strip(),
                    dimension=str(row.get('Dimensi칩n', '')),
                    unidad_medida=str(row.get('Unidad_Medida', '')),
                    tipo_medida=str(row.get('Tipo_Medida', '')),
                    valor=float(row.get('Valor', 0)) if pd.notna(row.get('Valor')) else 0.0,
                    nivel_territorial=str(row.get('Nivel_Territorial', '')).upper(),
                    id_localidad=int(row.get('ID Localidad', 0)) if pd.notna(row.get('ID Localidad')) else None,
                    nombre_localidad=str(row.get('Nombre Localidad', '')).strip(),
                    id_upz=int(row.get('ID_UPZ', 0)) if pd.notna(row.get('ID_UPZ')) else None,
                    nombre_upz=str(row.get('Nombre_UPZ', '')).strip() if pd.notna(row.get('Nombre_UPZ')) else None,
                    area_geografica=str(row.get('츼rea Geogr치fica', '')),
                    a침o_inicio=int(row.get('A침o_Inicio', 0)) if pd.notna(row.get('A침o_Inicio')) else None,
                    periodicidad=str(row.get('Periodicidad', '')),
                    poblacion_base=str(row.get('Poblacion Base', '')),
                    semaforo=str(row.get('Semaforo', '')),
                    grupo_etario_asociado=str(row.get('Grupo Etario Asociado', '')),
                    sexo=str(row.get('Sexo', '')),
                    tipo_unidad=str(row.get('Tipo de Unidad', '')),
                    observacion=str(row.get('Observaci칩n', '')),
                    fuente=str(row.get('Fuente', '')),
                    url_fuente=str(row.get('URL_Fuente (Opcional)', ''))
                )
                
                db.add(registro)
                registros_cargados += 1
                
            except Exception as e:
                errores += 1
                logger.warning(f"Error en fila: {e}")
                continue
        
        db.commit()
        
        return {
            "status": "success",
            "mensaje": "Datos de fecundidad temprana cargados exitosamente",
            "registros_cargados": registros_cargados,
            "total_filas_procesadas": len(df),
            "errores": errores
        }
        
    except Exception as e:
        logger.error(f"Error cargando archivo: {e}")
        raise HTTPException(status_code=500, detail=f"Error procesando archivo: {str(e)}")

@app.get("/estadisticas/generales")
async def estadisticas_generales(db: Session = Depends(get_db)):
    """Estad칤sticas generales del sistema"""
    try:
        total_registros = db.query(IndicadorFecundidad).count()
        
        if total_registros == 0:
            return {
                "total_registros": 0,
                "localidades_unicas": 0,
                "upzs_unicas": 0,
                "indicadores_unicos": 0,
                "promedio_10_14": 0.0,
                "promedio_15_19": 0.0,
                "localidad_mayor_riesgo": "Sin datos",
                "localidad_menor_riesgo": "Sin datos",
                "a침os_disponibles": [],
                "mensaje": "No hay datos cargados. Por favor, carga un archivo Excel."
            }
        
        localidades = db.query(IndicadorFecundidad.nombre_localidad).distinct().count()
        upzs = db.query(IndicadorFecundidad.nombre_upz).filter(IndicadorFecundidad.nombre_upz.isnot(None)).distinct().count()
        indicadores = db.query(IndicadorFecundidad.indicador_nombre).distinct().count()
        
        # Promedios por grupo de edad (usando el indicador)
        registros_10_14 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%14%")
        ).all()
        
        registros_15_19 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%19%")
        ).all()
        
        prom_10_14 = np.mean([r.valor for r in registros_10_14]) if registros_10_14 else 0.0
        prom_15_19 = np.mean([r.valor for r in registros_15_19]) if registros_15_19 else 0.0
        
        # Localidades con mayor y menor riesgo
        localidades_riesgo = db.query(
            IndicadorFecundidad.nombre_localidad,
            func.avg(IndicadorFecundidad.valor).label('promedio')
        ).group_by(IndicadorFecundidad.nombre_localidad).all()
        
        if localidades_riesgo:
            mayor_riesgo = max(localidades_riesgo, key=lambda x: x.promedio).nombre_localidad
            menor_riesgo = min(localidades_riesgo, key=lambda x: x.promedio).nombre_localidad
        else:
            mayor_riesgo = menor_riesgo = "Sin datos"
        
        # A침os disponibles
        a침os = db.query(IndicadorFecundidad.a침o_inicio).filter(
            IndicadorFecundidad.a침o_inicio.isnot(None)
        ).distinct().all()
        a침os_disponibles = sorted([a.a침o_inicio for a in a침os if a.a침o_inicio])
        
        return {
            "total_registros": total_registros,
            "localidades_unicas": localidades,
            "upzs_unicas": upzs,
            "indicadores_unicos": indicadores,
            "promedio_10_14": round(float(prom_10_14), 2),
            "promedio_15_19": round(float(prom_15_19), 2),
            "localidad_mayor_riesgo": mayor_riesgo,
            "localidad_menor_riesgo": menor_riesgo,
            "a침os_disponibles": a침os_disponibles
        }
        
    except Exception as e:
        logger.error(f"Error calculando estad칤sticas: {e}")
        return {
            "total_registros": 0,
            "localidades_unicas": 0,
            "upzs_unicas": 0,
            "indicadores_unicos": 0,
            "promedio_10_14": 0.0,
            "promedio_15_19": 0.0,
            "localidad_mayor_riesgo": "Error",
            "localidad_menor_riesgo": "Error",
            "a침os_disponibles": [],
            "error": str(e)
        }

@app.get("/datos/localidades")
async def datos_por_localidades(
    grupo_edad: Optional[str] = Query(None, description="10-14 o 15-19"),
    a침o: Optional[int] = Query(None, description="Filtrar por a침o"),
    db: Session = Depends(get_db)
):
    """Datos agregados por localidades"""
    try:
        query = db.query(IndicadorFecundidad)
        
        # Filtros
        if grupo_edad == "10-14":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%14%")
            )
        elif grupo_edad == "15-19":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%19%")
            )
        
        if a침o:
            query = query.filter(IndicadorFecundidad.a침o_inicio == a침o)
        
        resultados = query.all()
        
        # Agrupar por localidad
        localidades_data = {}
        for r in resultados:
            localidad = r.nombre_localidad
            if localidad not in localidades_data:
                localidades_data[localidad] = []
            localidades_data[localidad].append(r.valor)
        
        datos = []
        for localidad, valores in localidades_data.items():
            if valores:
                promedio = np.mean(valores)
                grupo_detectado = extraer_grupo_edad(
                    resultados[0].indicador_nombre if resultados else "",
                    resultados[0].grupo_etario_asociado if resultados else ""
                )
                nivel_riesgo = calcular_nivel_riesgo(promedio, grupo_detectado)
                
                datos.append({
                    "localidad": localidad,
                    "promedio": round(promedio, 2),
                    "total_registros": len(valores),
                    "maximo": round(max(valores), 2),
                    "minimo": round(min(valores), 2),
                    "nivel_riesgo": nivel_riesgo,
                    "grupo_edad": grupo_detectado
                })
        
        datos.sort(key=lambda x: x["promedio"], reverse=True)
        return {"datos": datos, "total": len(datos)}
        
    except Exception as e:
        logger.error(f"Error obteniendo datos por localidades: {e}")
        raise HTTPException(status_code=500, detail="Error obteniendo datos")

@app.get("/datos/upz")
async def datos_por_upz(
    localidad: Optional[str] = Query(None, description="Filtrar por localidad"),
    grupo_edad: Optional[str] = Query(None, description="10-14 o 15-19"),
    db: Session = Depends(get_db)
):
    """Datos agregados por UPZ"""
    try:
        query = db.query(IndicadorFecundidad).filter(IndicadorFecundidad.nombre_upz.isnot(None))
        
        if localidad:
            query = query.filter(IndicadorFecundidad.nombre_localidad == localidad)
        
        if grupo_edad == "10-14":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.contains("10") & 
                IndicadorFecundidad.indicador_nombre.contains("14")
            )
        elif grupo_edad == "15-19":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.contains("15") & 
                IndicadorFecundidad.indicador_nombre.contains("19")
            )
        
        resultados = query.all()
        
        # Agrupar por UPZ
        upz_data = {}
        for r in resultados:
            key = (r.nombre_localidad, r.nombre_upz)
            if key not in upz_data:
                upz_data[key] = []
            upz_data[key].append(r.valor)
        
        datos = []
        for (localidad, upz), valores in upz_data.items():
            if valores:
                promedio = np.mean(valores)
                grupo_detectado = extraer_grupo_edad(
                    resultados[0].indicador_nombre if resultados else "",
                    resultados[0].grupo_etario_asociado if resultados else ""
                )
                nivel_riesgo = calcular_nivel_riesgo(promedio, grupo_detectado)
                
                datos.append({
                    "localidad": localidad,
                    "upz": upz,
                    "promedio": round(promedio, 2),
                    "total_registros": len(valores),
                    "maximo": round(max(valores), 2),
                    "minimo": round(min(valores), 2),
                    "nivel_riesgo": nivel_riesgo,
                    "grupo_edad": grupo_detectado
                })
        
        datos.sort(key=lambda x: x["promedio"], reverse=True)
        return {"datos": datos, "total": len(datos)}
        
    except Exception as e:
        logger.error(f"Error obteniendo datos por UPZ: {e}")
        raise HTTPException(status_code=500, detail="Error obteniendo datos")

@app.get("/analisis/correlaciones")
async def analisis_correlaciones(
    nivel: str = Query("LOCALIDAD", description="LOCALIDAD o UPZ"),
    db: Session = Depends(get_db)
):
    """An치lisis de correlaciones entre grupos de edad"""
    try:
        # Obtener datos de ambos grupos de edad
        datos_10_14 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%14%") &
            IndicadorFecundidad.nivel_territorial == nivel.upper()
        ).all()
        
        datos_15_19 = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
            IndicadorFecundidad.indicador_nombre.ilike("%19%") &
            IndicadorFecundidad.nivel_territorial == nivel.upper()
        ).all()
        
        if not datos_10_14 or not datos_15_19:
            return {"mensaje": "Datos insuficientes para an치lisis de correlaci칩n"}
        
        # Crear matrices alineadas por territorio
        territorio_map_10_14 = {}
        territorio_map_15_19 = {}
        
        for d in datos_10_14:
            key = d.nombre_localidad if nivel == "LOCALIDAD" else d.nombre_upz
            if key not in territorio_map_10_14:
                territorio_map_10_14[key] = []
            territorio_map_10_14[key].append(d.valor)
        
        for d in datos_15_19:
            key = d.nombre_localidad if nivel == "LOCALIDAD" else d.nombre_upz
            if key not in territorio_map_15_19:
                territorio_map_15_19[key] = []
            territorio_map_15_19[key].append(d.valor)
        
        # Obtener territorios comunes
        territorios_comunes = set(territorio_map_10_14.keys()) & set(territorio_map_15_19.keys())
        
        if len(territorios_comunes) < 3:
            return {"mensaje": "Datos insuficientes para correlaci칩n estad칤sticamente v치lida"}
        
        valores_10_14 = [np.mean(territorio_map_10_14[t]) for t in territorios_comunes]
        valores_15_19 = [np.mean(territorio_map_15_19[t]) for t in territorios_comunes]
        
        # Calcular correlaciones
        r_pearson, p_pearson = stats.pearsonr(valores_10_14, valores_15_19)
        r_spearman, p_spearman = stats.spearmanr(valores_10_14, valores_15_19)
        
        def interpretar_correlacion(r):
            abs_r = abs(r)
            if abs_r >= 0.8: return "Muy fuerte"
            elif abs_r >= 0.6: return "Fuerte"
            elif abs_r >= 0.4: return "Moderada"
            elif abs_r >= 0.2: return "D칠bil"
            else: return "Muy d칠bil"
        
        return {
            "nivel_territorial": nivel,
            "territorios_analizados": len(territorios_comunes),
            "correlacion_pearson": round(r_pearson, 3),
            "significancia_pearson": round(p_pearson, 4),
            "correlacion_spearman": round(r_spearman, 3),
            "significancia_spearman": round(p_spearman, 4),
            "interpretacion_pearson": interpretar_correlacion(r_pearson),
            "interpretacion_spearman": interpretar_correlacion(r_spearman),
            "estadisticamente_significativo": p_pearson < 0.05,
            "datos_utilizados": {
                "promedio_10_14": round(np.mean(valores_10_14), 2),
                "promedio_15_19": round(np.mean(valores_15_19), 2),
                "territoos_comunes": list(territorios_comunes)[:10]  # Primeros 10
            }
        }
        
    except Exception as e:
        logger.error(f"Error en an치lisis de correlaciones: {e}")
        raise HTTPException(status_code=500, detail="Error en an치lisis de correlaciones")

@app.get("/analisis/ranking")
async def ranking_territorial(
    grupo_edad: str = Query("15-19", description="10-14 o 15-19"),
    nivel: str = Query("LOCALIDAD", description="LOCALIDAD o UPZ"),
    top: int = Query(10, description="N칰mero de resultados"),
    db: Session = Depends(get_db)
):
    """Ranking de territorios por nivel de riesgo"""
    try:
        query = db.query(IndicadorFecundidad).filter(
            IndicadorFecundidad.nivel_territorial == nivel.upper()
        )
        
        if grupo_edad == "10-14":
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%10%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%14%")
            )
        else:
            query = query.filter(
                IndicadorFecundidad.indicador_nombre.ilike("%15%") & 
                IndicadorFecundidad.indicador_nombre.ilike("%19%")
            )
        
        resultados = query.all()
        
        # Agrupar por territorio
        territorio_data = {}
        for r in resultados:
            territorio = r.nombre_localidad if nivel == "LOCALIDAD" else r.nombre_upz
            if territorio not in territorio_data:
                territorio_data[territorio] = []
            territorio_data[territorio].append(r.valor)
        
        # Calcular estad칤sticas por territorio
        ranking = []
        for territorio, valores in territorio_data.items():
            if valores:
                promedio = np.mean(valores)
                nivel_riesgo = calcular_nivel_riesgo(promedio, grupo_edad)
                
                ranking.append({
                    "territorio": territorio,
                    "promedio": round(promedio, 2),
                    "nivel_riesgo": nivel_riesgo,
                    "total_registros": len(valores),
                    "desviacion_estandar": round(np.std(valores), 2),
                    "coeficiente_variacion": round((np.std(valores) / promedio) * 100, 2) if promedio > 0 else 0
                })
        
        # Ordenar por promedio descendente
        ranking.sort(key=lambda x: x["promedio"], reverse=True)
        
        return {
            "grupo_edad": grupo_edad,
            "nivel_territorial": nivel,
            "total_territorios": len(ranking),
            "ranking_mayor_riesgo": ranking[:top],
            "ranking_menor_riesgo": ranking[-top:][::-1],
            "resumen": {
                "promedio_general": round(np.mean([r["promedio"] for r in ranking]), 2),
                "territorios_criticos": len([r for r in ranking if r["nivel_riesgo"] == "CR칈TICO"]),
                "territorios_altos": len([r for r in ranking if r["nivel_riesgo"] == "ALTO"]),
                "territorios_moderados": len([r for r in ranking if r["nivel_riesgo"] == "MODERADO"]),
                "territorios_bajos": len([r for r in ranking if r["nivel_riesgo"] == "BAJO"])
            }
        }
        
    except Exception as e:
        logger.error(f"Error en ranking territorial: {e}")
        raise HTTPException(status_code=500, detail="Error generando ranking")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT", 8000)))
